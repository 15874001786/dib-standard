import{_ as e,c as t,o as a,a2 as p}from"./chunks/framework.LV4lgCXr.js";const b=JSON.parse('{"title":"前端开发规约","description":"","frontmatter":{},"headers":[],"relativePath":"web-standard.md","filePath":"web-standard.md"}'),n={name:"web-standard.md"},s=p(`<h1 id="前端开发规约" tabindex="-1">前端开发规约 <a class="header-anchor" href="#前端开发规约" aria-label="Permalink to &quot;前端开发规约&quot;">​</a></h1><p>html、css、js、ts代码具体规范</p><p><a href="./html.html">html规约</a></p><p><a href="./css.html">css规约</a></p><p><a href="./javascript.html">js规约</a></p><p><a href="./typescript.html">ts规约</a></p><h2 id="工程化配置" tabindex="-1">工程化配置 <a class="header-anchor" href="#工程化配置" aria-label="Permalink to &quot;工程化配置&quot;">​</a></h2><p>为了严格参照上述代码规范，需要工程化进行配置</p><p>推荐可选方案:</p><h3 id="_1-f2elint" tabindex="-1">1.F2Elint <a class="header-anchor" href="#_1-f2elint" aria-label="Permalink to &quot;1.F2Elint&quot;">​</a></h3><p>F2Elint 是由阿里巴巴团队开发的一款前端代码质量工具，可用于 JavaScript、TypeScript、Style/CSS/SCSS/Less、HTML/Markdown、Vue/ React 等前端全栈场景，也集成了 Prettier、ESLint、stylelint 等。</p><p>安装F2Elint：</p><div class="language-md vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">md</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">npx @f2elint/cli init</span></span></code></pre></div><p>这将会在你的项目中安装 F2Elint，并自动创建一个 .f2elintrc.js 配置文件。</p><p>配置 F2Elint：你可以编辑 .f2elintrc.js 文件来定制 F2Elint 的规则。F2Elint 的配置非常灵活，你可以根据项目需求来进行定制。</p><p>运行 F2Elint：在配置好 F2Elint 后，你可以通过运行 npm run lint 命令来检查你的代码。如果你在 package.json 中设置了相应的脚本，你也可以运行 npm run fix 来自动修复一些简单的问题。</p><p>集成到 CI/CD：你还可以将 F2Elint 集成到你的持续集成/持续部署（CI/CD）流程中，这样你就可以在代码提交到仓库时自动检查代码质量。</p><h3 id="_2-airbnb-base" tabindex="-1">2.airbnb-base <a class="header-anchor" href="#_2-airbnb-base" aria-label="Permalink to &quot;2.airbnb-base&quot;">​</a></h3><p>eslint-config-airbnb-base 是 Airbnb 公司开发并维护的一套 JavaScript 语言的编程规范，被广泛应用于许多项目中。使用这套，prettier可让团队自行编写成团队大部分成员所习惯的编码风格。</p><h3 id="_3-配置husky和lint-staged" tabindex="-1">3.配置Husky和lint-staged <a class="header-anchor" href="#_3-配置husky和lint-staged" aria-label="Permalink to &quot;3.配置Husky和lint-staged&quot;">​</a></h3><p><a href="https://juejin.cn/post/7085534305249656862" target="_blank" rel="noreferrer">husky+lint-staged介绍文章</a></p><p>上述为可参考文章</p><p>通过husky，去处理 git pre-commit和push等钩子，然后在pre-commit钩子中用lint-staged 去处理 git add 缓冲区中的提交内容，在Lint-staged中去执行 esint --fix，prettier --write 等。在钩子中也可执行tsc的检测校验，这个由开发团队自行决定。通过husky、lint-staged的配置，我们能做到</p><p>1.自动执行eslint prettier --fix、可让代码风格、规范统一</p><p>2.当工具检测不通过时则拦截commit的提交，初步通过工具去保证代码质量</p><p>需要在package script中写prepare: husky install，通常在npm i 后，会默认执行一遍prepare去进行husky的初始化，若不是通过Npm install的，也可手动输入prepare去初始化Husky</p><h3 id="_4-node依赖包与vscode插件统一" tabindex="-1">4.node依赖包与vscode插件统一 <a class="header-anchor" href="#_4-node依赖包与vscode插件统一" aria-label="Permalink to &quot;4.node依赖包与vscode插件统一&quot;">​</a></h3><p>在上述的eslint prettier配置完成后，需要在vscode中也安装eslint、pretteier的插件，插件会默认读取根目录下的.eslintrc .prettierrc，这样在vscode开发中，也能看到编辑器的eslint等报错，而进行及时的更改</p><h2 id="vue开发规约" tabindex="-1">Vue开发规约 <a class="header-anchor" href="#vue开发规约" aria-label="Permalink to &quot;Vue开发规约&quot;">​</a></h2><p>1.组件的文件名推荐采用首字母大写驼峰或者字母小写连字符的方式，例如：MyComponent.vue、my-component.vue。</p><p>2.组件名应该始终是多个单词的，根组件App和内置组件除外，这样做可以避免跟现有的以及未来的 HTML 元素冲突，因为所有的 HTML 元素名称都是单个单词的。</p><p>3.每个SFC组件，都需要有其name属性。name用处：</p><pre><code>在组件自己的模板中递归引用自己时。

在 Vue 开发者工具中的组件树显示时。

在组件抛出的警告追踪栈信息中显示时。

使用 KeepAlive，通过该属性来匹配需要缓存的组件时。
</code></pre><p>4.处理函数异步使用async + await，并且用上try catch去捕获错误</p><p>5.不要在onMounted钩子上去调用异步后端接口，理论上这个钩子只处理跟dom相关的逻辑，由于setup语法糖可以完成vue2 created钩子的工作，因此在setup中直接调用后端异步接口即可。</p><p>6.在对vue3响应式和reactive了解不深的情况下，统一使用ref去进行响应式定义。比如：</p><pre><code>当你对 reactive 创建的响应式对象进行解构操作时，你会丢失响应性

与解构类似，如果你对 reactive 创建的响应式对象进行展开操作（例如，使用 ... 操作符创建一个新对象），也会丢失响应性。

如果你使用 toRefs 或 toRaws 之类的函数将 reactive 创建的响应式对象转换为普通对象， 也会丢失响应性。
</code></pre><p>7.处理表格渲染等只需要初始赋值渲染，而不用后续给内部值改动的场景如表格列表渲染页面，统一使用shallowRef去替代ref。</p><p>8.为组件样式去设置作用域，修改ui框架的相关css代码在全局styles里面去维护一个如custom-element.scss的文件，去进行样式重写</p><p>9.vue-router的route name 命名规则通常是使用camelCase（驼峰式）或 kebab-case（短横线分隔式）。例如，myRoute 或 my-route。</p><p>10.不得破坏vue的单向数据流，举例：子组件修改父组件prop传过来的值。</p><pre><code>通常情况下，可以使用v-model配合computed set组合去修改适配上述场景，或者使用本地状态，一次性的emit修改父属性去处理。
</code></pre><p>11.避免内存泄漏，在组件onUnmounted中往往需要给bus.on，定时器等代码给上终止的操作</p><p>12.公共组件或者重要模块需要严格配置ts，一是静态检查，二是方便他人阅读</p><h2 id="代码评审" tabindex="-1">代码评审 <a class="header-anchor" href="#代码评审" aria-label="Permalink to &quot;代码评审&quot;">​</a></h2><p>在功能或fix bug的内容提mr后，组内开发人员就可以代码评审查看了，评审他人代码是个好的习惯，1者学习了解他人的代码，2者把控项目代码质量。code review往往是工程师之间关于代码交流的最好方式。</p><p>再优秀的工程师也有可能犯下低级错误，代码评审也是项目质量的最后一道关卡</p><p>代码评审需要做到</p><p>1.禁止重复造轮子，看到开发者重复造了轮子需要更正改进，尽量复用现有组件</p><p>2.组件封装复用，若一些功能是系统全局可能复用到的，需要单独抽离，封装成组件</p><p>3.针对公共区域的代码进行重点评审，不应此次改动可能影响到别的业务或者别的场景</p><p>4.禁止死循环或者内存泄漏代码</p><p>5.代码是否正确地处理了错误和边界情况？是否使用了错误边界组件？</p><p>6.是否避免了不必要的渲染和计算？或者说是否性能方面欠考虑，比如表格中添加表单组件，大量的组件渲染以及双向数据绑定会导致页面及其卡顿，这种情况是否使用了懒加载和异步组件？</p><p>7.核心模块，公共组件等是否严格使用了ts</p><p>8.css中的通用样式是否用了预编译器中的变量或者函数，禁止单独写死通用样式</p><p>至少需要一半的组内工程师评审完毕点击approve后，仓库拥有者owner点击合并，才可合并回rc，master分支</p>`,57),r=[s];function i(o,l,c,d,h,u){return a(),t("div",null,r)}const f=e(n,[["render",i]]);export{b as __pageData,f as default};
